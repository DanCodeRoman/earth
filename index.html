<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hyper‑Realistic Earth Meteor Impact Simulation</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.75);
      padding: 10px;
      border-radius: 5px;
      color: #fff;
      z-index: 10;
    }
    #sendMeteor {
      margin-top: 5px;
      padding: 5px 10px;
      background: #1e90ff;
      border: none;
      color: #fff;
      border-radius: 3px;
      cursor: pointer;
    }
    #sendMeteor:hover {
      background: #3ba9ff;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label for="meteorSize">Meteor Size: <span id="meteorSizeDisplay">1.0</span></label><br>
    <input type="range" id="meteorSize" min="0.5" max="5" step="0.1" value="1.0"><br>
    <button id="sendMeteor">Send Meteor</button>
    <p>Click on Earth to set impact target.</p>
  </div>
  
  <!-- Load Three.js and OrbitControls from CDNs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // ----- Global Variables & Setup -----
    let scene, camera, renderer, controls;
    let earth, clouds;
    let raycaster, mouse;
    let targetPoint = null;
    let meteor = null, meteorCurve = null, meteorProgress = 0;
    let explosion = null, explosionTime = 0;
    let cameraShake = { intensity: 0, duration: 0, time: 0 };
    const clock = new THREE.Clock();

    // UI Elements
    const meteorSizeSlider = document.getElementById("meteorSize");
    const meteorSizeDisplay = document.getElementById("meteorSizeDisplay");
    const sendMeteorButton = document.getElementById("sendMeteor");

    meteorSizeSlider.addEventListener("input", () => {
      meteorSizeDisplay.textContent = meteorSizeSlider.value;
    });

    // Initialize scene, camera, lights, and objects.
    init();
    animate();

    function init() {
      // Scene & Camera
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
      camera.position.set(0, 0, 150);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Orbit Controls for user interaction
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(100, 50, 100);
      scene.add(directionalLight);

      // Raycaster & mouse for picking
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Create Hyper‑Realistic Earth
      createEarth();

      // Listen for window resize
      window.addEventListener("resize", onWindowResize, false);
      
      // Listen for mouse clicks (for impact target)
      renderer.domElement.addEventListener("click", onMouseClick, false);
      
      // UI: Send Meteor button
      sendMeteorButton.addEventListener("click", launchMeteor, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ----- Creating the Hyper‑Realistic Earth -----
    function createEarth() {
      const loader = new THREE.TextureLoader();

      // High resolution textures from a public repository (4K maps)
      const earthTexture = loader.load("https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg");
      const bumpTexture  = loader.load("https://raw.githubusercontent.com/turban/webgl-earth/master/images/elev_bump_4k.jpg");
      const specularTexture = loader.load("https://raw.githubusercontent.com/turban/webgl-earth/master/images/water_4k.png");
      const cloudTexture = loader.load("https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png");

      // Create Earth sphere geometry
      const earthGeometry = new THREE.SphereGeometry(50, 128, 128);
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        bumpMap: bumpTexture,
        bumpScale: 0.8,
        specularMap: specularTexture,
        specular: new THREE.Color(0x222222)
      });
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);

      // Create cloud layer (slightly larger sphere)
      const cloudGeometry = new THREE.SphereGeometry(50.5, 128, 128);
      const cloudMaterial = new THREE.MeshLambertMaterial({
        map: cloudTexture,
        transparent: true,
        opacity: 0.8,
        depthWrite: false
      });
      clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
      scene.add(clouds);
    }

    // ----- Raycasting to Pick an Impact Point on Earth -----
    function onMouseClick(event) {
      // Normalize mouse coordinates
      mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(earth);
      if (intersects.length > 0) {
        // Record the first intersection point as the target.
        targetPoint = intersects[0].point.clone();
        // Optionally, add a temporary marker (a small glowing sphere)
        addImpactMarker(targetPoint);
      }
    }
    
    function addImpactMarker(position) {
      // Create a short‑lived marker
      const markerGeometry = new THREE.SphereGeometry(1, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.copy(position);
      scene.add(marker);
      // Remove marker after 2 seconds.
      setTimeout(() => {
        scene.remove(marker);
      }, 2000);
    }

    // ----- Launching the Meteor -----
    function launchMeteor() {
      if (!targetPoint || meteor) return; // require an impact target and only one meteor at a time
      
      // Get meteor size from UI slider.
      const size = parseFloat(meteorSizeSlider.value);
      
      // Compute the incoming direction:
      // Since Earth is centered at (0,0,0) and targetPoint lies on its surface,
      // the inward (impact) direction is opposite the surface normal.
      const normal = targetPoint.clone().normalize();
      const offset = 100;  // distance from the surface where the meteor starts
      const startPoint = targetPoint.clone().sub(normal.clone().multiplyScalar(offset));
      
      // Define a control point for a curved (arc) trajectory.
      // We take the midpoint and add an offset perpendicular to the impact direction.
      const midPoint = new THREE.Vector3().addVectors(startPoint, targetPoint).multiplyScalar(0.5);
      let up = new THREE.Vector3(0, 1, 0);
      // Avoid collinearity if normal is nearly vertical.
      if (Math.abs(normal.dot(up)) > 0.95) {
        up = new THREE.Vector3(1, 0, 0);
      }
      const perpendicular = new THREE.Vector3().crossVectors(normal, up).cross(normal).normalize();
      const arcHeight = 50; // height of the arc
      const controlPoint = midPoint.clone().add(perpendicular.multiplyScalar(arcHeight));
      
      // Create a quadratic Bezier curve for the meteor path.
      meteorCurve = new THREE.QuadraticBezierCurve3(startPoint, controlPoint, targetPoint);
      meteorProgress = 0;
      
      // Create the meteor mesh.
      const meteorGeometry = new THREE.SphereGeometry(size, 32, 32);
      const meteorMaterial = new THREE.MeshBasicMaterial({
        color: 0xff5500,
        emissive: 0xffaa00
      });
      meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
      meteor.position.copy(startPoint);
      scene.add(meteor);
    }

    // ----- Explosion Effect -----
    function createExplosion(position, baseSize) {
      // Create a sphere that will expand and fade.
      const explosionGeometry = new THREE.SphereGeometry(1, 32, 32);
      const explosionMaterial = new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending
      });
      explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
      explosion.position.copy(position);
      scene.add(explosion);
      explosionTime = 0;
      
      // Initiate camera shake
      cameraShake.intensity = 2 * baseSize;
      cameraShake.duration = 0.5; // seconds
      cameraShake.time = 0;
    }

    // ----- Main Animation Loop -----
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      
      // Rotate Earth & Clouds slowly
      earth.rotation.y += 0.001;
      clouds.rotation.y += 0.0012;
      
      // Update controls
      controls.update();
      
      // If a meteor is active, move it along its path.
      if (meteor && meteorCurve) {
        meteorProgress += delta / 1.5; // meteor flight lasts ~1.5 seconds
        if (meteorProgress >= 1) {
          meteorProgress = 1;
          // Impact reached – remove meteor and trigger explosion.
          const impactPosition = meteorCurve.getPoint(1);
          scene.remove(meteor);
          meteor = null;
          createExplosion(impactPosition, parseFloat(meteorSizeSlider.value));
        } else {
          const pos = meteorCurve.getPoint(meteorProgress);
          meteor.position.copy(pos);
        }
      }
      
      // Update explosion: expand and fade out.
      if (explosion) {
        explosionTime += delta;
        const scale = THREE.MathUtils.lerp(1, 20, explosionTime / 1);
        explosion.scale.set(scale, scale, scale);
        explosion.material.opacity = THREE.MathUtils.lerp(1, 0, explosionTime / 1);
        if (explosionTime >= 1) {
          scene.remove(explosion);
          explosion = null;
        }
      }
      
      // Apply camera shake if active.
      if (cameraShake.time < cameraShake.duration) {
        cameraShake.time += delta;
        const shakeFactor = (1 - cameraShake.time / cameraShake.duration) * cameraShake.intensity;
        camera.position.x += (Math.random() - 0.5) * shakeFactor;
        camera.position.y += (Math.random() - 0.5) * shakeFactor;
      }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
